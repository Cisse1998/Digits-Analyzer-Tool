<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv Professional Chart</title>
    <style>
        :root {
            --background: #0a0b0e;
            --card: #111827;
            --foreground: #f8fafc;
            --primary: #3b82f6;
            --primary-foreground: #ffffff;
            --secondary: #1e293b;
            --border: #374151;
            --chart-bullish: #10b981;
            --chart-bearish: #ef4444;
            --muted-foreground: #9ca3af;
            --grid-color: rgba(255, 255, 255, 0.1);
        }

        .light-mode {
            --background: #f8fafc;
            --card: #ffffff;
            --foreground: #0f172a;
            --primary: #3b82f6;
            --primary-foreground: #ffffff;
            --secondary: #f1f5f9;
            --border: #e2e8f0;
            --chart-bullish: #10b981;
            --chart-bearish: #ef4444;
            --muted-foreground: #64748b;
            --grid-color: rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: var(--background);
            color: var(--foreground);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            background: var(--card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status-bar {
            display: flex;
            gap: 15px;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--secondary);
            border-radius: 20px;
            font-size: 14px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Chart Container */
        .chart-container {
            background: var(--card);
            border-radius: 12px;
            padding: 0;
            border: 1px solid var(--border);
            margin-bottom: 20px;
            overflow: hidden;
        }

        /* Chart Controls */
        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            background: var(--secondary);
        }

        .left-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chart-type-btn {
            padding: 8px 16px;
            background: var(--background);
            border: 1px solid var(--border);
            color: var(--foreground);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chart-type-btn.active {
            background: var(--primary);
            color: var(--primary-foreground);
            border-color: var(--primary);
        }

        .separator {
            width: 1px;
            height: 20px;
            background: var(--border);
            margin: 0 10px;
        }

        .timeframe-controls {
            display: flex;
            gap: 4px;
        }

        .timeframe-btn {
            padding: 6px 12px;
            background: var(--background);
            border: 1px solid var(--border);
            color: var(--foreground);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .timeframe-btn.active {
            background: var(--primary);
            color: var(--primary-foreground);
            border-color: var(--primary);
        }

        /* Right Controls */
        .right-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .tick-indicator {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid #3b82f6;
            color: #3b82f6;
        }

        .tick-indicator.up {
            background: rgba(16, 185, 129, 0.1);
            border-color: #10b981;
            color: #10b981;
        }

        .tick-indicator.down {
            background: rgba(239, 68, 68, 0.1);
            border-color: #ef4444;
            color: #ef4444;
        }

        /* Price Display */
        .price-display {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .symbol-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .symbol-name {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .price-value {
            font-size: 1.8rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        .price-value.up {
            color: #10b981;
        }

        .price-value.down {
            color: #ef4444;
        }

        .price-change {
            font-size: 0.9rem;
            color: var(--muted-foreground);
        }

        /* Chart Canvas */
        .chart-canvas-container {
            height: 500px;
            position: relative;
            background: var(--background);
        }

        #priceChart {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Indicators Panel */
        .indicators-panel {
            padding: 15px 20px;
            border-top: 1px solid var(--border);
            background: var(--secondary);
        }

        .indicators-list {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .indicator-badge {
            padding: 6px 12px;
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .indicator-color {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* Loading */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--muted-foreground);
            font-size: 14px;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
        }

        .theme-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--secondary);
            border: 1px solid var(--border);
            color: var(--foreground);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <!-- Theme Toggle -->
    <div class="theme-toggle">
        <button class="theme-btn" id="themeToggle">üåô</button>
    </div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-top">
                <h1>Deriv Professional Chart</h1>
                <div class="status-bar">
                    <div class="status">
                        <span class="status-dot"></span>
                        <span id="connectionStatus">Connected</span>
                    </div>
                    <div class="status">
                        <span>Symbol: <span id="currentSymbol">1HZ10V</span></span>
                    </div>
                    <div class="status">
                        <span>Ticks: <span id="tickCount">0</span></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chart Container -->
        <div class="chart-container">
            <!-- Chart Controls -->
            <div class="chart-controls">
                <div class="left-controls">
                    <button class="chart-type-btn active" id="candleBtn">
                        <span>üìä</span> Candles
                    </button>
                    <button class="chart-type-btn" id="lineBtn">
                        <span>üìà</span> Line
                    </button>
                    <div class="separator"></div>
                    <div class="timeframe-controls">
                        <button class="timeframe-btn active" data-timeframe="60">1M</button>
                        <button class="timeframe-btn" data-timeframe="300">5M</button>
                        <button class="timeframe-btn" data-timeframe="900">15M</button>
                        <button class="timeframe-btn" data-timeframe="1800">30M</button>
                        <button class="timeframe-btn" data-timeframe="3600">1H</button>
                    </div>
                </div>
                <div class="right-controls">
                    <div class="tick-indicator" id="tickIndicator">-</div>
                    <div>
                        <div style="font-size: 12px; color: var(--muted-foreground);">Last Price</div>
                        <div style="font-size: 16px; font-weight: 600;" id="lastPrice">--.--</div>
                    </div>
                </div>
            </div>

            <!-- Price Display -->
            <div class="price-display">
                <div class="symbol-info">
                    <div class="symbol-name" id="symbolName">Volatility 10 (1s) Index</div>
                    <div class="price-value" id="currentPrice">--.--</div>
                    <div class="price-change" id="priceChange">+0.00 (0.00%)</div>
                </div>
            </div>

            <!-- Chart Canvas -->
            <div class="chart-canvas-container">
                <canvas id="priceChart"></canvas>
                <div class="loading" id="chartLoading">Loading chart data...</div>
            </div>

            <!-- Indicators Panel -->
            <div class="indicators-panel">
                <div class="indicators-list" id="indicatorsList">
                    <!-- Indicators will be added here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const DERIV_WS_URL = 'wss://ws.binaryws.com/websockets/v3?app_id=1089';
        const MAX_CANDLES = 200;
        const MIN_VISIBLE_CANDLES = 50;
        const ZOOM_STEP = 0.2;

        // Supported symbols
        const SYMBOLS = {
            '1HZ10V': 'Volatility 10 (1s) Index',
            'R_10': 'Volatility 10 Index',
            '1HZ15V': 'Volatility 15 (1s) Index',
            '1HZ25V': 'Volatility 25 (1s) Index',
            'R_25': 'Volatility 25 Index',
            '1HZ30V': 'Volatility 30 (1s) Index',
            '1HZ50V': 'Volatility 50 (1s) Index',
            'R_50': 'Volatility 50 Index',
            '1HZ75V': 'Volatility 75 (1s) Index',
            'R_75': 'Volatility 75 Index',
            '1HZ90V': 'Volatility 90 (1s) Index',
            '1HZ100V': 'Volatility 100 (1s) Index',
            'R_100': 'Volatility 100 Index'
        };

        // Global state
        let socket = null;
        let activeSymbol = '1HZ10V';
        let activeTimeframe = 60;
        let chartType = 'candlestick';
        let candles = [];
        let currentCandle = null;
        let currentPrice = 0;
        let previousPrice = 0;
        let ticks = [];
        let zoomLevel = 1;
        let panOffset = 0;
        let indicators = new Set(['SMA', 'EMA', 'BB']);
        let ctx = null;
        let canvas = null;

        // Theme management
        function initTheme() {
            const themeBtn = document.getElementById('themeToggle');
            const savedTheme = localStorage.getItem('theme') || 'dark';
            
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                themeBtn.textContent = 'üåô';
            } else {
                themeBtn.textContent = '‚òÄÔ∏è';
            }
            
            themeBtn.addEventListener('click', () => {
                if (document.body.classList.contains('light-mode')) {
                    document.body.classList.remove('light-mode');
                    localStorage.setItem('theme', 'dark');
                    themeBtn.textContent = '‚òÄÔ∏è';
                } else {
                    document.body.classList.add('light-mode');
                    localStorage.setItem('theme', 'light');
                    themeBtn.textContent = 'üåô';
                }
                drawChart();
            });
        }

        // Initialize chart
        function initChart() {
            canvas = document.getElementById('priceChart');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Event listeners
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // Initial draw
            drawChart();
        }

        // Handle zoom and pan
        let isDragging = false;
        let dragStartX = 0;
        let dragStartOffset = 0;

        function handleWheel(e) {
            e.preventDefault();
            
            if (e.ctrlKey || e.metaKey) {
                // Zoom
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            } else {
                // Pan
                panOffset = Math.max(0, Math.min(
                    panOffset - e.deltaY * 0.5,
                    Math.max(0, candles.length - getVisibleCandleCount())
                ));
            }
            
            drawChart();
        }

        function handleMouseDown(e) {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartOffset = panOffset;
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - dragStartX;
            const pixelToCandleRatio = getVisibleCandleCount() / canvas.width;
            panOffset = Math.max(0, Math.min(
                dragStartOffset - deltaX * pixelToCandleRatio,
                Math.max(0, candles.length - getVisibleCandleCount())
            ));
            
            drawChart();
        }

        function handleMouseUp() {
            isDragging = false;
        }

        function zoomIn() {
            zoomLevel = Math.min(zoomLevel + ZOOM_STEP, candles.length / MIN_VISIBLE_CANDLES);
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel - ZOOM_STEP, 1);
        }

        function getVisibleCandleCount() {
            return Math.max(MIN_VISIBLE_CANDLES, Math.floor(candles.length / zoomLevel));
        }

        // Chart drawing
        function drawChart() {
            if (!ctx || !canvas) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (candles.length === 0) {
                drawNoData();
                return;
            }
            
            // Calculate visible range
            const visibleCount = getVisibleCandleCount();
            const startIndex = Math.max(0, Math.floor(panOffset));
            const endIndex = Math.min(startIndex + visibleCount, candles.length);
            const visibleCandles = candles.slice(startIndex, endIndex);
            
            if (visibleCandles.length === 0) return;
            
            // Calculate price range
            const priceRange = getPriceRange(visibleCandles);
            
            // Draw grid
            drawGrid(priceRange, visibleCandles.length);
            
            // Draw indicators
            drawIndicators(visibleCandles, priceRange, startIndex);
            
            // Draw candles or line
            if (chartType === 'candlestick') {
                drawCandlesticks(visibleCandles, priceRange);
            } else {
                drawLineChart(visibleCandles, priceRange);
            }
            
            // Draw current price line
            if (currentPrice > 0) {
                drawCurrentPriceLine(priceRange);
            }
            
            // Draw axes
            drawAxes(priceRange, visibleCandles);
        }

        function getPriceRange(candles) {
            let min = Infinity;
            let max = -Infinity;
            
            candles.forEach(candle => {
                min = Math.min(min, candle.low);
                max = Math.max(max, candle.high);
            });
            
            // Add indicators to range
            if (indicators.has('SMA')) {
                const sma = calculateSMA(candles, 20);
                sma.forEach(val => {
                    if (val) {
                        min = Math.min(min, val);
                        max = Math.max(max, val);
                    }
                });
            }
            
            if (indicators.has('EMA')) {
                const ema = calculateEMA(candles, 20);
                ema.forEach(val => {
                    if (val) {
                        min = Math.min(min, val);
                        max = Math.max(max, val);
                    }
                });
            }
            
            if (indicators.has('BB')) {
                const bb = calculateBollingerBands(candles, 20, 2);
                bb.upper.forEach((val, i) => {
                    if (val && bb.lower[i]) {
                        min = Math.min(min, bb.lower[i]);
                        max = Math.max(max, val);
                    }
                });
            }
            
            // Add padding
            const padding = (max - min) * 0.1;
            return {
                min: min - padding,
                max: max + padding
            };
        }

        function drawGrid(priceRange, candleCount) {
            const padding = { left: 70, right: 20, top: 30, bottom: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Grid lines
            ctx.strokeStyle = document.body.classList.contains('light-mode') 
                ? 'rgba(0, 0, 0, 0.1)' 
                : 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = padding.top + (i * chartHeight / 10);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
            }
            
            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = padding.left + (i * chartWidth / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + chartHeight);
                ctx.stroke();
            }
            
            // Price labels
            ctx.fillStyle = document.body.classList.contains('light-mode') ? '#666' : '#aaa';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'right';
            
            for (let i = 0; i <= 10; i++) {
                const price = priceRange.max - (priceRange.max - priceRange.min) * i / 10;
                const y = padding.top + (i * chartHeight / 10);
                ctx.fillText(price.toFixed(2), padding.left - 10, y + 4);
            }
            
            // Time labels
            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const index = Math.floor((i / 5) * (candleCount - 1));
                if (index < 0 || index >= candleCount) continue;
                
                const x = padding.left + (i * chartWidth / 5);
                const time = new Date(candles[Math.floor(panOffset) + index].time);
                const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
                ctx.fillText(timeStr, x, chartHeight + padding.top + 20);
            }
        }

        function drawIndicators(candles, priceRange, startIndex) {
            const padding = { left: 70, right: 20, top: 30, bottom: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Bollinger Bands
            if (indicators.has('BB')) {
                const bb = calculateBollingerBands(candles, 20, 2);
                
                // Fill between bands
                ctx.fillStyle = document.body.classList.contains('light-mode') 
                    ? 'rgba(139, 92, 246, 0.1)' 
                    : 'rgba(139, 92, 246, 0.15)';
                ctx.beginPath();
                
                for (let i = 0; i < candles.length; i++) {
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((bb.upper[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                for (let i = candles.length - 1; i >= 0; i--) {
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((bb.lower[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();
                
                // Draw bands
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 2]);
                
                // Upper band
                ctx.beginPath();
                for (let i = 0; i < candles.length; i++) {
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((bb.upper[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Middle band
                ctx.lineWidth = 1.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                for (let i = 0; i < candles.length; i++) {
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((bb.middle[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Lower band
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                for (let i = 0; i < candles.length; i++) {
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((bb.lower[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            // SMA
            if (indicators.has('SMA')) {
                const sma = calculateSMA(candles, 20);
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < candles.length; i++) {
                    if (!sma[i]) continue;
                    
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((sma[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    
                    if (i === 0 || !sma[i-1]) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // EMA
            if (indicators.has('EMA')) {
                const ema = calculateEMA(candles, 20);
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < candles.length; i++) {
                    if (!ema[i]) continue;
                    
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((ema[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    
                    if (i === 0 || !ema[i-1]) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // ALMA
            if (indicators.has('ALMA')) {
                const alma = calculateALMA(candles, 9);
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < candles.length; i++) {
                    if (!alma[i]) continue;
                    
                    const x = padding.left + (i * chartWidth / (candles.length - 1));
                    const y = padding.top + chartHeight - ((alma[i] - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                    
                    if (i === 0 || !alma[i-1]) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        function drawCandlesticks(candles, priceRange) {
            const padding = { left: 70, right: 20, top: 30, bottom: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            const candleWidth = Math.max(2, Math.min(20, chartWidth / candles.length * 0.7));
            
            for (let i = 0; i < candles.length; i++) {
                const candle = candles[i];
                const isBullish = candle.close >= candle.open;
                const color = isBullish ? '#10b981' : '#ef4444';
                
                // Calculate positions
                const x = padding.left + (i * chartWidth / (candles.length - 1)) + (chartWidth / candles.length / 2);
                const openY = padding.top + chartHeight - ((candle.open - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                const closeY = padding.top + chartHeight - ((candle.close - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                const highY = padding.top + chartHeight - ((candle.high - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                const lowY = padding.top + chartHeight - ((candle.low - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                
                // Draw wick
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, Math.min(openY, closeY));
                ctx.moveTo(x, Math.max(openY, closeY));
                ctx.lineTo(x, lowY);
                ctx.stroke();
                
                // Draw body
                ctx.fillStyle = color;
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.max(Math.abs(closeY - openY), 1);
                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
            }
        }

        function drawLineChart(candles, priceRange) {
            const padding = { left: 70, right: 20, top: 30, bottom: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < candles.length; i++) {
                const x = padding.left + (i * chartWidth / (candles.length - 1));
                const y = padding.top + chartHeight - ((candles[i].close - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw dots at data points
            ctx.fillStyle = '#3b82f6';
            for (let i = 0; i < candles.length; i += Math.max(1, Math.floor(candles.length / 10))) {
                const x = padding.left + (i * chartWidth / (candles.length - 1));
                const y = padding.top + chartHeight - ((candles[i].close - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawCurrentPriceLine(priceRange) {
            const padding = { left: 70, right: 20, top: 30, bottom: 40 };
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            const y = padding.top + chartHeight - ((currentPrice - priceRange.min) / (priceRange.max - priceRange.min)) * chartHeight;
            
            ctx.strokeStyle = currentPrice > previousPrice ? '#10b981' : '#ef4444';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            
            ctx.beginPath();
            ctx.moveTo(padding.left, y);
            ctx.lineTo(canvas.width - padding.right, y);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Draw price label
            ctx.fillStyle = currentPrice > previousPrice ? '#10b981' : '#ef4444';
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(currentPrice.toFixed(2), canvas.width - 10, y + 4);
        }

        function drawAxes(priceRange, candles) {
            const padding = { left: 70, right: 20, top: 30, bottom: 40 };
            
            // Y-axis line
            ctx.strokeStyle = document.body.classList.contains('light-mode') ? '#000' : '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, canvas.height - padding.bottom);
            ctx.stroke();
            
            // X-axis line
            ctx.beginPath();
            ctx.moveTo(padding.left, canvas.height - padding.bottom);
            ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
            ctx.stroke();
        }

        function drawNoData() {
            ctx.fillStyle = document.body.classList.contains('light-mode') ? '#666' : '#999';
            ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Waiting for market data...', canvas.width / 2, canvas.height / 2);
        }

        // Indicator calculations
        function calculateSMA(candles, period) {
            if (candles.length < period) return new Array(candles.length).fill(null);
            
            const sma = new Array(candles.length).fill(null);
            for (let i = period - 1; i < candles.length; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += candles[i - j].close;
                }
                sma[i] = sum / period;
            }
            return sma;
        }

        function calculateEMA(candles, period) {
            if (candles.length < period) return new Array(candles.length).fill(null);
            
            const multiplier = 2 / (period + 1);
            let ema = candles[0].close;
            const emaValues = new Array(candles.length).fill(null);
            emaValues[0] = ema;
            
            for (let i = 1; i < candles.length; i++) {
                ema = (candles[i].close - ema) * multiplier + ema;
                emaValues[i] = ema;
            }
            return emaValues;
        }

        function calculateBollingerBands(candles, period, stdDev) {
            if (candles.length < period) {
                return {
                    upper: new Array(candles.length).fill(null),
                    middle: new Array(candles.length).fill(null),
                    lower: new Array(candles.length).fill(null)
                };
            }
            
            const upper = new Array(candles.length).fill(null);
            const middle = new Array(candles.length).fill(null);
            const lower = new Array(candles.length).fill(null);
            
            for (let i = period - 1; i < candles.length; i++) {
                // Calculate SMA
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += candles[i - j].close;
                }
                const sma = sum / period;
                
                // Calculate standard deviation
                let variance = 0;
                for (let j = 0; j < period; j++) {
                    variance += Math.pow(candles[i - j].close - sma, 2);
                }
                const std = Math.sqrt(variance / period);
                
                upper[i] = sma + (std * stdDev);
                middle[i] = sma;
                lower[i] = sma - (std * stdDev);
            }
            
            return { upper, middle, lower };
        }

        function calculateALMA(candles, period) {
            if (candles.length < period) return new Array(candles.length).fill(null);
            
            const offset = 0.85;
            const sigma = 6;
            const m = Math.floor(offset * (period - 1));
            const s = period / sigma;
            
            const alma = new Array(candles.length).fill(null);
            
            for (let i = period - 1; i < candles.length; i++) {
                let sum = 0;
                let weightSum = 0;
                
                for (let j = 0; j < period; j++) {
                    const weight = Math.exp(-((j - m) * (j - m)) / (2 * s * s));
                    sum += candles[i - period + 1 + j].close * weight;
                    weightSum += weight;
                }
                
                alma[i] = sum / weightSum;
            }
            
            return alma;
        }

        // WebSocket connection
        function connectToDeriv() {
            try {
                socket = new WebSocket(DERIV_WS_URL);
                
                socket.onopen = () => {
                    console.log('Connected to Deriv WebSocket');
                    updateConnectionStatus('Connected');
                    subscribeToSymbol(activeSymbol);
                    document.getElementById('chartLoading').style.display = 'none';
                };
                
                socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleDerivMessage(data);
                    } catch (error) {
                        console.error('Error parsing message:', error);
                    }
                };
                
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('Error');
                };
                
                socket.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateConnectionStatus('Disconnected');
                    setTimeout(connectToDeriv, 5000);
                };
            } catch (error) {
                console.error('Failed to connect:', error);
                updateConnectionStatus('Failed');
            }
        }

        function subscribeToSymbol(symbol) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            const msg = {
                ticks: symbol,
                subscribe: 1
            };
            
            socket.send(JSON.stringify(msg));
            
            // Request historical candles
            setTimeout(() => {
                requestHistoricalCandles();
            }, 1000);
        }

        function requestHistoricalCandles() {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            
            const msg = {
                ticks_history: activeSymbol,
                end: 'latest',
                count: MAX_CANDLES,
                style: 'candles',
                granularity: activeTimeframe,
                subscribe: 0
            };
            
            socket.send(JSON.stringify(msg));
        }

        function handleDerivMessage(data) {
            if (data.msg_type === 'tick') {
                handleTickData(data.tick);
            } else if (data.msg_type === 'candles') {
                handleCandleData(data.candles);
            } else if (data.msg_type === 'ohlc') {
                handleOHLCData(data.ohlc);
            }
        }

        function handleTickData(tick) {
            if (!tick || !tick.quote) return;
            
            previousPrice = currentPrice;
            currentPrice = parseFloat(tick.quote);
            
            // Update tick indicator
            const indicator = document.getElementById('tickIndicator');
            if (currentPrice > previousPrice) {
                indicator.textContent = '‚Üë';
                indicator.className = 'tick-indicator up';
            } else if (currentPrice < previousPrice) {
                indicator.textContent = '‚Üì';
                indicator.className = 'tick-indicator down';
            } else {
                indicator.textContent = '-';
                indicator.className = 'tick-indicator';
            }
            
            // Update price display
            document.getElementById('lastPrice').textContent = currentPrice.toFixed(2);
            document.getElementById('currentPrice').textContent = currentPrice.toFixed(2);
            
            const priceElement = document.getElementById('currentPrice');
            if (currentPrice > previousPrice) {
                priceElement.className = 'price-value up';
            } else if (currentPrice < previousPrice) {
                priceElement.className = 'price-value down';
            }
            
            // Update change percentage
            if (previousPrice > 0) {
                const change = ((currentPrice - previousPrice) / previousPrice) * 100;
                document.getElementById('priceChange').textContent = 
                    `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
            }
            
            // Update tick count
            document.getElementById('tickCount').textContent = 
                parseInt(document.getElementById('tickCount').textContent) + 1;
            
            // Update chart
            drawChart();
        }

        function handleCandleData(candleData) {
            if (!candleData || candleData.length === 0) return;
            
            candles = candleData.map(candle => ({
                time: candle.epoch * 1000,
                open: parseFloat(candle.open),
                high: parseFloat(candle.high),
                low: parseFloat(candle.low),
                close: parseFloat(candle.close),
                volume: parseFloat(candle.volume) || 0
            }));
            
            drawChart();
        }

        function handleOHLCData(ohlc) {
            if (!ohlc) return;
            
            // Update current candle
            const candleTime = ohlc.open_time * 1000;
            const existingIndex = candles.findIndex(c => c.time === candleTime);
            
            const candle = {
                time: candleTime,
                open: parseFloat(ohlc.open),
                high: parseFloat(ohlc.high),
                low: parseFloat(ohlc.low),
                close: parseFloat(ohlc.close),
                volume: parseFloat(ohlc.volume) || 0
            };
            
            if (existingIndex >= 0) {
                candles[existingIndex] = candle;
            } else {
                candles.push(candle);
                if (candles.length > MAX_CANDLES) {
                    candles.shift();
                }
            }
            
            drawChart();
        }

        function updateConnectionStatus(status) {
            document.getElementById('connectionStatus').textContent = status;
        }

        // Initialize
        function init() {
            initTheme();
            initChart();
            connectToDeriv();
            
            // Event listeners
            document.getElementById('candleBtn').addEventListener('click', () => {
                chartType = 'candlestick';
                document.getElementById('candleBtn').classList.add('active');
                document.getElementById('lineBtn').classList.remove('active');
                drawChart();
            });
            
            document.getElementById('lineBtn').addEventListener('click', () => {
                chartType = 'line';
                document.getElementById('lineBtn').classList.add('active');
                document.getElementById('candleBtn').classList.remove('active');
                drawChart();
            });
            
            document.querySelectorAll('.timeframe-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    activeTimeframe = parseInt(e.target.dataset.timeframe);
                    requestHistoricalCandles();
                });
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (canvas) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                    drawChart();
                }
            });
        }

        // Start everything
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
